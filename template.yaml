#Author: Nathan ward

AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: SAM-based robo trader for stocks and options.

Globals:
  Function:
    #Documentation and other DeploymentPreference Types can be found here: https://github.com/awslabs/serverless-application-model/blob/master/docs/safe_lambda_deployments.rst
    AutoPublishAlias: live
    DeploymentPreference:
      Type: AllAtOnce
  Api:
    BinaryMediaTypes:
      #The ~1 will be replaced with / when deployed
      - '*~1*'

Outputs:
  RoboTraderApiEndpoint:
    Description: "API Gateway endpoint URL to access manager UI."
    Value: {'Fn::Sub': 'https://${RoboTraderWebsiteHTTPApi}.execute-api.${AWS::Region}.amazonaws.com/'}
  StackArn:
    Description: "Use this as the stack_arn in your cloud_formation_deployment_stack override."
    Value: {Ref: 'AWS::StackId'}

Parameters:
  AttachLambdaFunctionToVPC: { Type: String, Default: 'false', AllowedValues: ['true', 'false']}
  Stage: {Type: String, Default: 'prod'}

Conditions:
  RunLambdaInVPC:
    Fn::Equals: [ {Ref: AttachLambdaFunctionToVPC}, "true"]
  IsProd:
    Fn::Equals:
      - Ref: Stage
      - prod

Resources:
  #API gateway configuration. Using HTTP so I can avoid the forced stage route with REST.
  #Used as a lambda proxy, so most responses come from lambda. 401's are custom since
  #API gateway auths using cognito.
  RoboTraderWebsiteHTTPApi:
    Type: AWS::Serverless::HttpApi
    Properties:
      DefinitionBody:
        openapi: '3.0'
        info:
          title: {'Fn::Sub': '${AWS::StackName}-HttpApi'}
          description: API definition for robo trader website.
        #Paths are declared in AWS::Serverless::Function macro, this is a dummy value.
        paths:
          /:
            get:
              responses: {}
        x-amazon-apigateway-cors:
          allowHeaders:
            - Authorization
            - Content-Type
            - Location
            - Cookie
          allowMethods:
            - '*'
          maxAge: 86400
      Auth:
        Authorizers:
          OpenIdAuthorizer:
            #Would prefer to use cookies but seems like Authorization is the only one that works right now.
            IdentitySource: $request.header.Authorization
            JwtConfiguration:
              audience:
                - {Ref: RoboTraderCognitoUserPoolClient}
              issuer: {'Fn::Sub': 'https://cognito-idp.${AWS::Region}.amazonaws.com/${RoboTraderCognitoUserPool}'}
        DefaultAuthorizer: OpenIdAuthorizer
  #Lambda function handler for API gateway
  RoboTraderWebsiteFunction:
    Type: AWS::Serverless::Function
    DependsOn:
      - RoboTraderCognitoUserPool
      - RoboTraderCognitoUserPoolClient
      - StaticWebAssetsS3Bucket
    Properties:
      Description: Handler for API gateway to vend web requests.
      MemorySize: 256
      Handler: app.lambda_handler
      Runtime: python3.7
      CodeUri: robo_trade/
      Timeout: 5
      Policies:
        - Version: '2012-10-17'
          #Access to read determine if a Cognito user has been created (registered).
          Statement:
          - Action: ['cognito-idp:DescribeUserPool']
            Effect: Allow
            Resource: 'arn:aws:cognito-idp:*:*:userpool/*'
        - Version: '2012-10-17'
          #Access to create SSM parameters
          Statement:
          - Action: ['ssm:PutParameter', 'ssm:GetParameter']
            Effect: Allow
            Resource: 'arn:aws:ssm:*:*:parameter/*'
      Events:
        #Base react website. Client-side handles redirecting to login page.
        root:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: /
            Method: get
            Auth:
              Authorizer: NONE
        #Login and registration pages.
        loginpage:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: /login
            Method: get
            Auth:
              Authorizer: NONE
        registerpage:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: /register
            Method: get
            Auth:
              Authorizer: NONE
        #Unauthenticated route used to tell the user if they need to register.
        checkuserapi:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: /api/checkusercreated
            Method: get
            Auth:
              Authorizer: NONE
        #Static files dynamic routes. Vends a 301 redirect to S3.
        staticfiless3:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: '/static/{proxy+}'
            Method: get
            Auth:
              Authorizer: NONE
        assetfiless3:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: '/assets/{proxy+}'
            Method: get
            Auth:
              Authorizer: NONE
        #Catch-all for any other route not excplicity declared. Requires cognito auth.
        getProxy:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: '/{proxy+}'
            Method: get
        postProxy:
          Type: HttpApi
          Properties:
            ApiId: {Ref: RoboTraderWebsiteHTTPApi}
            Path: '/{proxy+}'
            Method: post
      Environment:
        Variables:
          #Cognito user pool identity id, and client ID required for login and registration.
          COGNITO_USER_POOL_ID: {Ref: RoboTraderCognitoUserPool}
          COGNITO_CLIENT_ID: {Ref: RoboTraderCognitoUserPoolClient}
          COGNITO_IDENTITY_ID: {Ref: RoboTraderCognitoIdentityPool}
          #S3 bucket URL for static assets. 
          STATIC_ASSETS_BUCKET: { 'Fn::GetAtt' : StaticWebAssetsS3Bucket.RegionalDomainName}
  #Cognito user pool for API gateway auth.
  RoboTraderCognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: RoboTraderCognitoPool
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: false
      Policies:
        PasswordPolicy:
          MinimumLength: 8
      UsernameAttributes:
        - email
      Schema:
        - AttributeDataType: String
          Name: email
          Required: false
  #Cognito user pool client. Required for the identity pool.
  RoboTraderCognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: {Ref: RoboTraderCognitoUserPool}
      #Force JWT refresh tokens to only be valid for one day.
      #Refresh tokens are stored client-side.
      RefreshTokenValidity: 1
  #Cognito identity pool for Api gateway auth.
  RoboTraderCognitoIdentityPool:
    Type: AWS::Cognito::IdentityPool
    DependsOn: RoboTraderCognitoUserPoolClient
    Properties:
      AllowUnauthenticatedIdentities: false
      CognitoIdentityProviders:
        - ClientId: {Ref: RoboTraderCognitoUserPoolClient}
          ProviderName: { 'Fn::GetAtt' : RoboTraderCognitoUserPool.ProviderName}
  #Cognito identity pool role to assume.
  RoboTraderCognitoRoleAccessPolicy:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          -
            Effect: 'Allow'
            Action:
              - 'sts:AssumeRoleWithWebIdentity'
            Condition: { "ForAnyValue:StringLike": {"cognito-identity.amazonaws.com:amr": "authenticated" },  "StringEquals": {"cognito-identity.amazonaws.com:aud": {Ref: RoboTraderCognitoIdentityPool}}}
            Principal:
              Federated:
                - 'cognito-identity.amazonaws.com'
      Path: '/'
      'Policies':
        -
          PolicyName: RoboTraderCognitoRoleAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              -
                Effect: 'Allow'
                Action:
                  - 'cloudformation:ListStacks'
                  - 'cloudformation:ListStackResources'
                Resource:  '*'
  #Attach Cognito policy.
  IdentityPoolRoleAttachment:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId: {Ref: RoboTraderCognitoIdentityPool}
      Roles: {"authenticated": { 'Fn::GetAtt' : RoboTraderCognitoRoleAccessPolicy.Arn}}
  #Lambda function to auto confirm Cognito users when they're created in Cognito.
  AutoConfirmUserFunction:
    Type: AWS::Serverless::Function
    Properties:
      Description: Handler auto confirming Cognito users.
      MemorySize: 128
      Handler: cfn_lambda.auto_confirm_cognito.lambda_handler
      Runtime: python3.7
      CodeUri: robo_trade/
      Timeout: 3
      Events:
        cognito:
          Type: Cognito
          Properties:
            Trigger: PreSignUp
            UserPool: {Ref: RoboTraderCognitoUserPool}
  #Permissions for Cognito to invoke the lambda.
  ConfirmUserInvocationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: { 'Fn::GetAtt' : AutoConfirmUserFunction.Arn}
      Principal: cognito-idp.amazonaws.com
      SourceArn: { 'Fn::GetAtt' : RoboTraderCognitoUserPool.Arn}
  #Static website assets bucket. Has public access enabled.
  StaticWebAssetsS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: { 'Fn::Join' : [ '-', [ 'rtstatic', { Ref: 'AWS::Region' }, { Ref: 'AWS::AccountId' }, {Ref: Stage}]]}
      PublicAccessBlockConfiguration:
        RestrictPublicBuckets: False
      CorsConfiguration: 
        CorsRules:
          - AllowedHeaders: ["*"]
            AllowedMethods: ["GET", "HEAD"]
            AllowedOrigins: ["*"]
            Id: "RTStaticAssetsCorsRule"
            MaxAge: 86400
  #Lambda function to sync static assets to s3.
  SyncStaticAssetsS3Lambda:
    Type: AWS::Serverless::Function
    Properties:
      Description: Handler to sync static assets to s3.
      MemorySize: 256
      Handler: cfn_lambda.deploy_static_files.lambda_handler
      Runtime: python3.7
      CodeUri: robo_trade/
      Timeout: 60
      Policies:
        - S3CrudPolicy:
            BucketName:
              Ref: StaticWebAssetsS3Bucket
      Environment:
        Variables:
          #Static assets bucket.
          S3_STATIC_ASSETS_BUCKET: {Ref: StaticWebAssetsS3Bucket}
          #Version of the website zip file. Increment this to trigger an update.
          WEBSITE_VERSION: "1.0.0"
  #Custom resource to trigger syncing of static files to s3.
  #Runs on create, and when WebsiteZipBuildVersion parameter is incremented,
  #then on update as well.
  SyncStaticAssetsS3:
    Type: 'Custom::SyncStaticAssetsS3'
    DependsOn:
      - SyncStaticAssetsS3Lambda
      - StaticWebAssetsS3Bucket
    Properties:
      ServiceToken: { 'Fn::GetAtt' : SyncStaticAssetsS3Lambda.Arn}
  #Master (global) settings for the site and trader bot, stored in SSM since there are only a few.
  SettingGlobalTradingEnabled:
    Type: "AWS::SSM::Parameter"
    Properties: 
      Name: "EpithyTrader_GlobalTradingEnabled"
      Description: "Global emergency stop for all automated trading."
      Type: String
      Value: "True"
  SettingShareResultsPublic:
    Type: "AWS::SSM::Parameter"
    Properties: 
      Name: "EpithyTrader_ShareResultsPublic"
      Description: "Setting to control whether or not you want to share your trades publically."
      Type: String
      Value: "False"
  SettingMobileNumber:
    Type: "AWS::SSM::Parameter"
    Properties: 
      Name: "EpithyTrader_MobileNumber"
      Description: "Your mobile number to receive SMS alerts if enabled."
      Type: String
      Value: "+"
  #Trade history and activity dynamo table. 
  TradeActivityDDBTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: { 'Fn::Join' : [ '-', [ 'TradeActivity', { Ref: 'AWS::Region' }, { Ref: 'AWS::AccountId' }, {Ref: Stage}]]}
      BillingMode: PAY_PER_REQUEST
      KeySchema: 
        - AttributeName: tradeId
          KeyType: HASH
        - AttributeName: tradeBuyDate
          KeyType: RANGE
      AttributeDefinitions: 
        - AttributeName: tradeId
          AttributeType: S
        - AttributeName: tradeBuyDate
          AttributeType: S
  #SQS Queues to manage order flow and ongoing operations.
  IgnitionQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: EpithyIgnitionQueue
      DelaySeconds: 0
      VisibilityTimeout: 11
      MessageRetentionPeriod: 901
  ExtendedHoursQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: EpithyExtendedHoursQueue.fifo
      FifoQueue: true
      ContentBasedDeduplication: true
      DelaySeconds: 1
      VisibilityTimeout: 4
      MessageRetentionPeriod: 60
  MarketHoursQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: EpithyMarketHoursQueue.fifo
      FifoQueue: true
      ContentBasedDeduplication: true
      DelaySeconds: 1
      VisibilityTimeout: 4
      MessageRetentionPeriod: 60
  ReconcilliationQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: EpithyReconcilliationQueue.fifo
      FifoQueue: true
      ContentBasedDeduplication: true
      DelaySeconds: 0
      VisibilityTimeout: 31
      MessageRetentionPeriod: 60
  #Permissions to allow lambdas to read/write to the queues
  LambdaQueueAccess:
    Type: AWS::SQS::QueuePolicy
    Properties: 
      PolicyDocument:
        Id: QueuePolicy
        Version: '2012-10-17'
        Statement:
        - Action:
          - sqs:SendMessage
          - sqs:ReceiveMessage
          - sqs:DeleteMessage
          - sqs:GetQueueAttributes
          - sqs:PurgeQueue
          Condition:
            ArnLike:
              aws:SourceArn: {'Fn::Sub': 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:*'}
          Effect: Allow
          Principal: '*'
          Resource: {'Fn::Sub': 'arn:aws:sqs:${AWS::Region}:${AWS::AccountId}:*'}
          Sid: Allow-Access-To-Queues
      Queues: 
        - {Ref: IgnitionQueue}
        - {Ref: ExtendedHoursQueue}
        - {Ref: MarketHoursQueue}
        - {Ref: ReconcilliationQueue}
  #Ignition lambda function to start trading.
  TradingIgnitionLambda:
    Type: AWS::Serverless::Function
    Properties:
      Description: Ignition lambda function to start the short circuit.
      MemorySize: 128
      Handler: trade_lambda.ignition.lambda_handler
      Runtime: python3.7
      CodeUri: robo_trade/
      Timeout: 10
      Policies:
        - Version: '2012-10-17'
          #Access to read and write to sqs.
          Statement:
          - Action: ['sqs:ReceiveMessage', 'sqs:DeleteMessage', 'sqs:GetQueueAttributes', 'sqs:SendMessage']
            Effect: Allow
            Resource: {'Fn::Sub': 'arn:aws:sqs:${AWS::Region}:${AWS::AccountId}:*'}
        - Version: '2012-10-17'
          #Access to read SSM for configuration settings.
          Statement:
          - Action: ['ssm:GetParameter']
            Effect: Allow
            Resource: 'arn:aws:ssm:*:*:parameter/*'
      Events:
        SQSInitiator:
          Type: SQS
          Properties:
            BatchSize: 1
            Enabled: true
            Queue: { 'Fn::GetAtt' : IgnitionQueue.Arn}
      Environment:
        Variables:
          IGNITION_QUEUE_NAME: {Ref: IgnitionQueue}
          EXTENDED_QUEUE_NAME: {Ref: ExtendedHoursQueue}
          MARKET_QUEUE_NAME: {Ref: MarketHoursQueue}
  #Cloudwatch event to start trading by triggering the inigition lambda.
  #Scheduler is for UTC, so have to start an hour early and let code handle DST.
  StartTradingCloudwatchEvent:
    Type: AWS::Events::Rule
    Properties:
      Description: This event triggers the start of the trading day.
      State: ENABLED
      Targets:
        - Arn: { 'Fn::GetAtt' : TradingIgnitionLambda.Arn}
          Id: IgnitionLambda
      ScheduleExpression: 'cron(0 12 ? * MON-FRI *)'